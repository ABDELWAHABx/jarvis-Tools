{
  "services": [
    {
      "name": "Rich Text Parser",
      "summary": "Turn HTML or Markdown into Google Docs-friendly instructions so agents can create polished docs automatically.",
      "docs_url": "http://localhost:8000/docs#/parser",
      "endpoints": [
        {
          "method": "POST",
          "path": "/parse/html",
          "headline": "HTML to Google Docs",
          "tagline": "Feed marketing-approved HTML and receive the Google Docs operations to recreate it.",
          "description": "Convert HTML markup into Google Docs batchUpdate requests.",
          "request": {
            "content_type": "application/json",
            "model": "HTMLParseRequest",
            "fields": {
              "html": "string – HTML markup to convert."
            },
            "example": {
              "html": "<h1>Hello World</h1><p>This becomes a Google Doc.</p>"
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "GoogleDocsBatchUpdate",
            "fields": {
              "requests": "list – Google Docs API batchUpdate operations."
            },
            "example": {
              "requests": [
                {
                  "insertText": {
                    "location": {
                      "index": 1
                    },
                    "text": "Hello World\n"
                  }
                }
              ]
            }
          }
        },
        {
          "method": "POST",
          "path": "/parse/markdown",
          "headline": "Markdown to Google Docs",
          "tagline": "Turn Markdown release notes into Google Docs-ready edits.",
          "description": "Convert Markdown into Google Docs batchUpdate requests via the HTML pipeline.",
          "request": {
            "content_type": "application/json",
            "model": "MarkdownParseRequest",
            "fields": {
              "markdown": "string – Markdown content to convert."
            },
            "example": {
              "markdown": "# Release Notes\n- Item one\n- Item two"
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "GoogleDocsBatchUpdate",
            "fields": {
              "requests": "list – Google Docs API batchUpdate operations."
            }
          }
        },
        {
          "method": "POST",
          "path": "/parse/docs/html",
          "headline": "HTML quick convert",
          "tagline": "Convert HTML instantly without touching the async queue.",
          "description": "Synchronous HTML conversion helper for Google Docs batchUpdate payloads.",
          "request": {
            "content_type": "application/json",
            "model": "HTMLParseRequest",
            "fields": {
              "html": "string – HTML markup to convert."
            }
          },
          "response": {
            "content_type": "application/json",
            "fields": {
              "requests": "list – Google Docs API batchUpdate operations."
            }
          },
          "notes": [
            "Optimized for n8n HTTP Request nodes where async queues are unnecessary."
          ]
        },
        {
          "method": "POST",
          "path": "/parse/docs/markdown",
          "headline": "Markdown quick convert",
          "tagline": "Use when you want Markdown converted to Google Docs edits in real time.",
          "description": "Synchronous Markdown conversion helper for Google Docs batchUpdate payloads.",
          "request": {
            "content_type": "application/json",
            "model": "MarkdownParseRequest",
            "fields": {
              "markdown": "string – Markdown content to convert."
            }
          },
          "response": {
            "content_type": "application/json",
            "fields": {
              "requests": "list – Google Docs API batchUpdate operations."
            }
          }
        },
        {
          "method": "POST",
          "path": "/parse/queue/html",
          "headline": "Queue HTML conversion",
          "tagline": "Hand off large HTML conversions to the background worker and poll later.",
          "description": "Enqueue HTML conversion work to Redis/RQ for long-running jobs.",
          "request": {
            "content_type": "application/json",
            "model": "HTMLParseRequest",
            "fields": {
              "html": "string – HTML markup to convert."
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "EnqueueResponse",
            "fields": {
              "job_id": "string – Identifier that can be polled via /parse/job/{id}."
            }
          }
        },
        {
          "method": "POST",
          "path": "/parse/queue/markdown",
          "headline": "Queue Markdown conversion",
          "tagline": "Offload Markdown conversions to the queue when they might take a while.",
          "description": "Enqueue Markdown conversion work to Redis/RQ for long-running jobs.",
          "request": {
            "content_type": "application/json",
            "model": "MarkdownParseRequest",
            "fields": {
              "markdown": "string – Markdown content to convert."
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "EnqueueResponse",
            "fields": {
              "job_id": "string – Identifier that can be polled via /parse/job/{id}."
            }
          }
        },
        {
          "method": "GET",
          "path": "/parse/job/{job_id}",
          "headline": "Check queued job",
          "tagline": "See whether a queued conversion is still running, finished, or failed.",
          "description": "Check the status of a queued conversion job.",
          "response": {
            "content_type": "application/json",
            "fields": {
              "status": "string – queued|started|finished|failed|unknown.",
              "result": "object – Present when status=finished.",
              "error": "string – Present when status=failed."
            }
          }
        }
      ],
      "flow": [
        "Call POST /parse/html or /parse/markdown to convert authoring content into Google Docs requests immediately.",
        "For instant Docs payloads skip the queue with POST /parse/docs/(html|markdown); enqueue large jobs via /parse/queue/* and poll /parse/job/{job_id}.",
        "Forward the returned requests array to the Google Docs batchUpdate API to build or update a document."
      ]
    },
    {
      "name": "Image Effects",
      "summary": "Expose the Before & After swipe generator and Halations glow filter via REST APIs.",
      "docs_url": "http://localhost:8000/docs#/image-tools",
      "endpoints": [
        {
          "method": "POST",
          "path": "/image-tools/before-after",
          "headline": "Before ↔ After Animation",
          "tagline": "Create looping swipe videos from two images – straight from your automations.",
          "description": "Uploads two images and returns a base64 MP4 (or binary stream) with a sliding divider that mimics the FUT-Coding before-and-after tool.",
          "request": {
            "content_type": "multipart/form-data",
            "fields": {
              "before_image": "file – Image showing the 'before' state.",
              "after_image": "file – Image showing the 'after' state.",
              "frame_width": "int (optional) – Override output width.",
              "frame_height": "int (optional) – Override output height.",
              "duration_seconds": "float (optional) – Clip duration (default 6s).",
              "fps": "int (optional) – Frame rate (default 30).",
              "cycles": "int (optional) – Number of divider passes (default 2).",
              "line_thickness": "int (optional) – Divider thickness (default 6px).",
              "add_text": "bool (optional) – Enable overlay text.",
              "overlay_text": "string (optional) – Text content rendered when add_text is true.",
              "response_format": "query: json|binary – Choose JSON (base64) or MP4 stream."
            },
            "notes": [
              "When no optional parameters are supplied the API responds with a hint explaining customisation options."
            ]
          },
          "response": {
            "content_type": "application/json",
            "fields": {
              "video_base64": "string – Base64 encoded MP4 clip.",
              "metadata": "object – Echoes dimensions, fps, duration, etc.",
              "message": "string – Optional hint about available parameters."
            }
          }
        },
        {
          "method": "POST",
          "path": "/image-tools/halations",
          "headline": "Halations Glow",
          "tagline": "Wrap the FUT-Coding halations image filter inside Tools API.",
          "description": "Applies a brightness-driven glow effect inspired by the halations open-source project.",
          "request": {
            "content_type": "multipart/form-data",
            "fields": {
              "image": "file – Source image.",
              "blur_amount": "float (optional) – Blur radius for the glow mask (default 10).",
              "brightness_threshold": "int (optional) – Highlight threshold (default 200).",
              "strength": "float (optional) – Intensity of the overlay (default 50).",
              "response_format": "query: json|binary – Choose JSON (base64) or JPEG stream."
            },
            "notes": [
              "Default requests include a hint about tweaking blur_amount, brightness_threshold, and strength."
            ]
          },
          "response": {
            "content_type": "application/json",
            "fields": {
              "image_base64": "string – Base64 encoded JPEG with glow applied.",
              "metadata": "object – Echoes dimensions and parameter values.",
              "message": "string – Optional hint about available parameters."
            }
          }
        }
      ],
      "flow": [
        "POST /image-tools/halations or /image-tools/before-after with form-data uploads to generate visuals.",
        "Set response_format=binary when you want the raw media stream; otherwise read the base64 payload from the JSON response.",
        "Store or forward the metadata block to keep track of dimensions and render options."
      ]
    },
    {
      "name": "Google Docs JSON Parser",
      "summary": "Pull plain text, links, and image references out of Google Docs JSON exports for downstream automations.",
      "docs_url": "http://localhost:8000/docs#/Google_Docs_Parser",
      "endpoints": [
        {
          "method": "POST",
          "path": "/parse/gdocs/json",
          "headline": "Docs to text",
          "tagline": "Paste a Google Docs JSON export and receive clean text, links, and image references.",
          "description": "Parse a Google Docs JSON payload produced by the Google Docs API.",
          "request": {
            "content_type": "application/json",
            "model": "GoogleDocs JSON",
            "fields": {
              "Content": "object – Raw Google Docs document JSON."
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "GoogleDocsParseResponse",
            "fields": {
              "text": "string – Plain text extracted from the document.",
              "urls": "list – Hyperlinks that were present in the document.",
              "images": "list – Image URLs present in the document."
            }
          }
        },
        {
          "method": "POST",
          "path": "/parse/gdocs/file",
          "headline": "Docs file to text",
          "tagline": "Upload a saved Google Docs JSON file and pull out the essentials.",
          "description": "Upload a Google Docs JSON export file and receive structured output.",
          "request": {
            "content_type": "multipart/form-data",
            "fields": {
              "file": "file – Google Docs JSON export."
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "GoogleDocsParseResponse",
            "fields": {
              "text": "string",
              "urls": "list",
              "images": "list"
            }
          }
        }
      ],
      "flow": [
        "Export a Google Doc as JSON and send it to POST /parse/gdocs/json (or upload with /parse/gdocs/file).",
        "Use the plain text, URL list, and image references in automation steps or LLM prompts."
      ]
    },
    {
      "name": "Docx Toolkit",
      "summary": "Quickly turn uploaded .docx files into plain text for agents or LLMs.",
      "docs_url": "http://localhost:8000/docs#/docx",
      "endpoints": [
        {
          "method": "POST",
          "path": "/docx/parse",
          "headline": "DOCX to plain text",
          "tagline": "Send a .docx file and get back clean text with file metadata.",
          "description": "Upload a binary .docx file and extract plain text.",
          "request": {
            "content_type": "application/octet-stream",
            "fields": {
              "body": "bytes – Raw .docx binary data sent as the HTTP body."
            }
          },
          "response": {
            "content_type": "application/json",
            "fields": {
              "text": "string – Extracted plain text.",
              "size_bytes": "integer – Size of the uploaded file in bytes.",
              "content_type": "string – Content-Type header received from the client."
            }
          }
        }
      ],
      "flow": [
        "Upload a .docx file directly to POST /docx/parse (set the Content-Type header that matches the file).",
        "Use the returned text for AI prompts, search indexing, or to seed downstream document generators."
      ]
    },
    {
      "name": "JavaScript Tool Bridge",
      "summary": "Expose curated Node.js utilities – like the panorama splitter – through Tools API endpoints.",
      "docs_url": "http://localhost:8000/docs#/javascript-tools/panosplitter_js_tools_panosplitter_post",
      "endpoints": [
        {
          "method": "POST",
          "path": "/js-tools/panosplitter",
          "headline": "Panorama to Instagram-ready tiles",
          "tagline": "Upload a panoramic image and receive Instagram-ready slices plus a shareable full preview.",
          "description": "Runs the bundled JavaScript panosplitter CLI via Node.js to generate slices and a full-view preview.",
          "request": {
            "content_type": "multipart/form-data",
            "fields": {
              "image": "file – Panorama image (JPEG/PNG) to process.",
              "high_res": "boolean – Optional. Enable to keep the original height for higher resolution slices."
            }
          },
          "response": {
            "content_type": "application/json",
            "model": "PanosplitterResponse",
            "fields": {
              "metadata": "object – Slice counts, dimensions, and original filename.",
              "zip_file": "object – Base64 zip archive bundling all generated JPEGs.",
              "slices": "list – Base64-encoded slices with dimensions.",
              "full_view": "object – Base64-encoded hero panel for carousel cover.",
              "manifest": "object – Metadata and file listing also embedded as manifest.json inside the zip archive."
            }
          },
          "notes": [
            "Dependencies install automatically on first run (Node.js + npm required).",
            "Append `response_format=binary` to receive the raw .zip archive plus an `X-Panosplitter-Manifest` header for n8n binary items."
          ]
        },
        {
          "method": "POST",
          "path": "/js-tools/cobalt",
          "headline": "Cobalt-powered media downloads",
          "tagline": "Proxy downloads from your Cobalt instance while keeping automations in one place.",
          "description": "Forwards requests to a configured Cobalt media downloader deployment and optionally streams the resulting file.",
          "request": {
            "content_type": "application/json",
            "fields": {
              "url": "string – Source URL accepted by Cobalt (YouTube, TikTok, Instagram, etc.).",
              "response_format": "string – `json` (default) or `binary` to stream the file back to the caller.",
              "download_filename": "string – Optional filename override when streaming the binary response.",
              "additional_fields": "All other keys are passed directly to Cobalt (audioFormat, videoQuality, service-specific toggles)."
            }
          },
          "response": {
            "content_type": "application/json | application/octet-stream",
            "fields": {
              "status": "string – Cobalt status such as tunnel/redirect/picker/error.",
              "url": "string – Present when Cobalt returns a downloadable link."
            },
            "notes": [
              "Set the environment variable `COBALT_API_BASE_URL` (and optional auth scheme/token) before using this endpoint.",
              "When requesting `response_format=binary`, Tools API returns the media bytes and a `X-Cobalt-Metadata` header containing the JSON payload (base64)."
            ]
          }
        },
        {
          "method": "POST",
          "path": "/js-tools/cobalt/shortcuts/{shortcut}",
          "headline": "One-click Cobalt presets",
          "tagline": "Trigger opinionated download presets (YouTube audio, metadata-only, etc.) without hand-crafting payloads.",
          "description": "Applies a named preset from the shortcut registry and forwards the request to the configured Cobalt backend.",
          "request": {
            "content_type": "application/json",
            "fields": {
              "url": "string – Source URL.",
              "response_format": "string – Optional. Use 'binary' to stream the media file instead of JSON.",
              "extra_fields": "Any additional keys override the preset before reaching Cobalt."
            }
          },
          "response": {
            "content_type": "application/json | application/octet-stream",
            "fields": {
              "status": "string – Mirrors the Cobalt response status.",
              "url": "string – Direct download URL when response_format=json."
            },
            "notes": [
              "Binary responses include Content-Disposition and X-Cobalt-Metadata headers for automation platforms."
            ]
          }
        }
      ],
      "flow": [
        "Install Node.js so Tools API can bootstrap the bundled utilities (panosplitter and Cobalt helpers).",
        "POST /js-tools/panosplitter to split panoramas; request binary responses for ready-to-share zip archives.",
        "Configure COBALT_API_BASE_URL then call /js-tools/cobalt or /js-tools/cobalt/shortcuts/{slug} to proxy downloads through your Cobalt instance."
      ]
    },
    {
      "name": "Media Toolkit",
      "summary": "Download or inspect online media using the bundled yt-dlp integration.",
      "docs_url": "http://localhost:8000/docs#/media-tools/yt_dlp_media_yt_dlp_post",
      "endpoints": [
        {
          "method": "POST",
          "path": "/media/yt-dlp",
          "headline": "One-call yt-dlp",
          "tagline": "Request metadata or stream downloads from any URL yt-dlp supports.",
          "description": "Wraps yt-dlp with safe defaults for agent and automation workflows.",
          "request": {
            "content_type": "application/json",
            "fields": {
              "url": "string – URL to inspect or download.",
              "response_format": "string – 'json' (default metadata) or 'binary' to stream the file.",
              "filename": "string – Optional filename override when streaming the binary response.",
              "options": "object – Optional yt-dlp options such as format, playlist_items, proxy, or custom headers.",
              "mode": "string – 'video' (default), 'audio', or 'subtitles' to change the download behaviour.",
              "job_id": "string – Optional. Provide a unique identifier to stream progress updates via SSE.",
              "format_id": "string – Optional. Force a specific format reported by yt-dlp metadata.",
              "subtitle_source": "string – Optional. 'original' or 'auto' when requesting subtitles.",
              "subtitle_languages": "list|string – Languages to prioritise when subtitle workflows are enabled."
            }
          },
          "response": {
            "content_type": "application/json | video/* | audio/*",
            "fields": {
              "metadata": "object – yt-dlp info dictionary mirroring the CLI output when response_format=json."
            },
            "notes": [
              "Binary responses include automation-friendly headers: Content-Disposition and X-YtDlp-Metadata (base64 JSON)."
            ]
          }
        },
        {
          "method": "GET",
          "path": "/media/yt-dlp/files/{file_id}",
          "headline": "Fetch stored download",
          "tagline": "Retrieve the binary asset saved during a yt-dlp download request.",
          "description": "Streams a previously stored download by its identifier and echoes metadata headers.",
          "response": {
            "content_type": "application/octet-stream",
            "fields": {
              "body": "binary – Media file previously downloaded by yt-dlp."
            },
            "notes": [
              "Responses include X-YtDlp-Metadata (base64 JSON) plus a Content-Disposition filename."
            ]
          }
        },
        {
          "method": "GET",
          "path": "/media/yt-dlp/progress/{job_id}",
          "headline": "Live download progress",
          "tagline": "Subscribe to Server-Sent Events that mirror yt-dlp progress callbacks.",
          "description": "Streams JSON-formatted progress events when the POST /media/yt-dlp request supplies a job_id.",
          "response": {
            "content_type": "text/event-stream",
            "fields": {
              "event": "SSE stream – Progress, error, and completion messages encoded as JSON strings."
            },
            "notes": [
              "Events publish stages such as starting, downloading, packaging, complete, or error."
            ]
          }
        }
      ],
      "flow": [
        "POST /media/yt-dlp with response_format=json to inspect metadata or 'binary' to trigger a download (optionally provide job_id for live progress).",
        "When using job_id, subscribe to GET /media/yt-dlp/progress/{job_id} for Server-Sent Events that track the download pipeline.",
        "Read the download descriptor and fetch the stored file from GET /media/yt-dlp/files/{file_id}, or hand the metadata to your automation."
      ]
    }
  ]
}
