import base64
import json
from typing import Any, Dict, Literal
from urllib.parse import quote

from fastapi import APIRouter, File, Form, HTTPException, UploadFile, Query, Response
from pydantic import AnyHttpUrl, BaseModel, ConfigDict, Field

from app.config import settings
from app.services.cobalt_service import CobaltError, CobaltService
from app.services.cobalt_shortcuts import SHORTCUT_REGISTRY
from app.services.js_tool_service import JavaScriptToolError, run_panosplitter
from app.utils.logger import logger

router = APIRouter(prefix="/js-tools", tags=["javascript-tools"])


class ImagePayload(BaseModel):
    filename: str
    content_type: str
    base64: str = Field(..., description="Base64 encoded image data")
    width: int | None = None
    height: int | None = None


class ZipPayload(BaseModel):
    filename: str
    base64: str = Field(..., description="Base64 encoded zip archive")
    content_type: str


class PanosplitterMetadata(BaseModel):
    mode: str
    slice_count: int
    slice_width: int
    slice_height: int
    scaled_width: int
    scaled_height: int
    original_filename: str


class PanosplitterResponse(BaseModel):
    metadata: PanosplitterMetadata
    zip_file: ZipPayload
    slices: list[ImagePayload]
    full_view: ImagePayload
    manifest: Dict[str, Any] | None = Field(
        default=None,
        description="Lightweight manifest describing generated assets (included in the binary zip as manifest.json)",
    )


class CobaltRequest(BaseModel):
    url: AnyHttpUrl
    response_format: Literal["json", "binary"] = Field(
        "json",
        description="Set to 'binary' to receive the downloaded media directly as an octet-stream response.",
    )
    download_filename: str | None = Field(
        default=None,
        description="Override the filename suggested by the Cobalt service when requesting binary output.",
    )

    model_config = ConfigDict(extra="allow")

    def to_payload(self) -> Dict[str, Any]:
        payload = self.model_dump(exclude={"response_format", "download_filename"})
        payload["url"] = str(self.url)
        return payload


def _content_disposition(filename: str) -> str:
    encoded = quote(filename)
    return f"attachment; filename*=UTF-8''{encoded}"


def _cobalt_not_configured_message() -> str:
    return (
        "Cobalt integration is disabled. Provide COBALT_API_BASE_URL or remove the "
        "environment variable to use the built-in fallback."
    )


def _get_cobalt_service() -> CobaltService:
    if not settings.COBALT_API_BASE_URL:
        raise HTTPException(status_code=503, detail=_cobalt_not_configured_message())

    return CobaltService(
        base_url=settings.COBALT_API_BASE_URL,
        auth_scheme=settings.COBALT_API_AUTH_SCHEME,
        auth_token=settings.COBALT_API_AUTH_TOKEN,
        timeout=settings.COBALT_API_TIMEOUT,
    )


class CobaltShortcutRequest(BaseModel):
    url: AnyHttpUrl
    response_format: Literal["json", "binary"] | None = Field(
        default=None,
        description="Override the shortcut response format ('json' or 'binary').",
    )
    download_filename: str | None = Field(
        default=None,
        description="Optional filename override when requesting binary output.",
    )
    options: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional Cobalt payload fields to merge with the shortcut preset.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_payload(self, preset: Dict[str, Any]) -> Dict[str, Any]:
        payload = {**preset, **self.options}
        payload["url"] = str(self.url)
        return payload


@router.post("/panosplitter", response_model=PanosplitterResponse)
async def panosplitter_endpoint(
    image: UploadFile = File(..., description="Panorama image to split"),
    high_res: bool = Form(False, description="Use the high resolution splitting mode"),
    response_format: Literal["json", "binary"] = Query(
        "json",
        description="Set to 'binary' to receive a zip file instead of a JSON payload.",
    ),
):
    """Split a panorama image into Instagram-friendly slices using the JavaScript toolchain."""

    try:
        image_bytes = await image.read()
        if not image_bytes:
            raise HTTPException(status_code=400, detail="Uploaded file is empty")

        result = run_panosplitter(image_bytes, high_res=high_res, filename=image.filename)

        if response_format == "binary":
            zip_payload = result.get("zip_file", {})
            zip_base64 = zip_payload.get("base64")
            if not zip_base64:
                raise HTTPException(status_code=500, detail="Zip archive was not generated by the JavaScript tool")

            try:
                zip_bytes = base64.b64decode(zip_base64)
            except (TypeError, ValueError) as exc:
                raise HTTPException(status_code=500, detail="Zip archive payload was invalid") from exc

            manifest = {
                "metadata": result.get("metadata", {}),
                "slices": [
                    {k: v for k, v in slice_payload.items() if k != "base64"}
                    for slice_payload in result.get("slices", [])
                ],
                "full_view": {
                    k: v
                    for k, v in result.get("full_view", {}).items()
                    if k != "base64"
                },
            }
            manifest_json = json.dumps(manifest, ensure_ascii=False)
            headers = {
                "Content-Disposition": _content_disposition(zip_payload.get("filename", "panosplitter_slices.zip")),
                "X-Panosplitter-Manifest": base64.b64encode(manifest_json.encode("utf-8")).decode("utf-8"),
            }

            return Response(content=zip_bytes, media_type=zip_payload.get("content_type", "application/zip"), headers=headers)

        return result
    except JavaScriptToolError as exc:
        logger.error("JavaScript tool failed: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover - FastAPI will re-raise as HTTP 500
        logger.exception("Unexpected error running panosplitter")
        raise HTTPException(status_code=500, detail="Failed to process image") from exc


@router.post(
    "/cobalt",
    response_model=Dict[str, Any],
    responses={
        200: {
            "content": {
                "application/zip": {"schema": {"type": "string", "format": "binary"}},
                "application/octet-stream": {"schema": {"type": "string", "format": "binary"}},
            }
        }
    },
)
async def cobalt_endpoint(request: CobaltRequest):
    """Proxy media download requests to a configured Cobalt instance."""

    service = _get_cobalt_service()

    try:
        cobalt_result = await service.process(request.to_payload())
        if request.response_format == "binary":
            binary = await service.download_binary(cobalt_result, filename_override=request.download_filename)
            headers = {
                "Content-Disposition": _content_disposition(binary.filename),
                "X-Cobalt-Metadata": binary.encoded_metadata,
            }
            return Response(content=binary.content, media_type=binary.content_type, headers=headers)

        return cobalt_result
    except CobaltError as exc:
        logger.error("Cobalt integration failed: %s", exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc


@router.post(
    "/cobalt/shortcuts/{shortcut}",
    response_model=Dict[str, Any],
    responses={
        200: {
            "content": {
                "application/zip": {"schema": {"type": "string", "format": "binary"}},
                "application/octet-stream": {"schema": {"type": "string", "format": "binary"}},
            }
        }
    },
)
async def cobalt_shortcut(shortcut: str, request: CobaltShortcutRequest):
    """Execute a preconfigured Cobalt request with minimal input."""

    shortcut_key = shortcut.lower()
    shortcut_config = SHORTCUT_REGISTRY.get(shortcut_key)
    if not shortcut_config:
        raise HTTPException(status_code=404, detail=f"Unknown Cobalt shortcut: {shortcut}")

    service = _get_cobalt_service()

    try:
        payload = request.to_payload(shortcut_config.payload)
        cobalt_result = await service.process(payload)

        response_format = request.response_format or shortcut_config.response_format
        if response_format == "binary":
            binary = await service.download_binary(cobalt_result, filename_override=request.download_filename)
            headers = {
                "Content-Disposition": _content_disposition(binary.filename),
                "X-Cobalt-Metadata": binary.encoded_metadata,
            }
            return Response(content=binary.content, media_type=binary.content_type, headers=headers)

        body: Dict[str, Any] = {
            "shortcut": shortcut_config.slug,
            "status": cobalt_result.get("status"),
            "download_url": cobalt_result.get("url"),
            "filename": cobalt_result.get("filename"),
            "metadata": cobalt_result,
        }
        if request.download_filename:
            body["download_filename"] = request.download_filename

        return body
    except CobaltError as exc:
        logger.error("Cobalt shortcut '%s' failed: %s", shortcut_key, exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc
