import base64
import json
from typing import Any, Dict, Literal
from urllib.parse import quote

from fastapi import APIRouter, File, Form, HTTPException, UploadFile, Query, Response
from pydantic import AnyHttpUrl, BaseModel, ConfigDict, Field

from app.config import settings
from app.services.cobalt_service import CobaltError, CobaltService
from app.services.js_tool_service import JavaScriptToolError, run_panosplitter
from app.utils.logger import logger

router = APIRouter(prefix="/js-tools", tags=["javascript-tools"])


class ImagePayload(BaseModel):
    filename: str
    content_type: str
    base64: str = Field(..., description="Base64 encoded image data")
    width: int | None = None
    height: int | None = None


class ZipPayload(BaseModel):
    filename: str
    base64: str = Field(..., description="Base64 encoded zip archive")
    content_type: str


class PanosplitterMetadata(BaseModel):
    mode: str
    slice_count: int
    slice_width: int
    slice_height: int
    scaled_width: int
    scaled_height: int
    original_filename: str


class PanosplitterResponse(BaseModel):
    metadata: PanosplitterMetadata
    zip_file: ZipPayload
    slices: list[ImagePayload]
    full_view: ImagePayload
    manifest: Dict[str, Any] | None = Field(
        default=None,
        description="Lightweight manifest describing generated assets (included in the binary zip as manifest.json)",
    )


class CobaltRequest(BaseModel):
    url: AnyHttpUrl
    response_format: Literal["json", "binary"] = Field(
        "json",
        description="Set to 'binary' to receive the downloaded media directly as an octet-stream response.",
    )
    download_filename: str | None = Field(
        default=None,
        description="Override the filename suggested by the Cobalt service when requesting binary output.",
    )

    model_config = ConfigDict(extra="allow")

    def to_payload(self) -> Dict[str, Any]:
        payload = self.model_dump(exclude={"response_format", "download_filename"})
        payload["url"] = str(self.url)
        return payload


def _content_disposition(filename: str) -> str:
    encoded = quote(filename)
    return f"attachment; filename*=UTF-8''{encoded}"


@router.post("/panosplitter", response_model=PanosplitterResponse)
async def panosplitter_endpoint(
    image: UploadFile = File(..., description="Panorama image to split"),
    high_res: bool = Form(False, description="Use the high resolution splitting mode"),
    response_format: Literal["json", "binary"] = Query(
        "json",
        description="Set to 'binary' to receive a zip file instead of a JSON payload.",
    ),
):
    """Split a panorama image into Instagram-friendly slices using the JavaScript toolchain."""

    try:
        image_bytes = await image.read()
        if not image_bytes:
            raise HTTPException(status_code=400, detail="Uploaded file is empty")

        result = run_panosplitter(image_bytes, high_res=high_res, filename=image.filename)

        if response_format == "binary":
            zip_payload = result.get("zip_file", {})
            zip_base64 = zip_payload.get("base64")
            if not zip_base64:
                raise HTTPException(status_code=500, detail="Zip archive was not generated by the JavaScript tool")

            try:
                zip_bytes = base64.b64decode(zip_base64)
            except (TypeError, ValueError) as exc:
                raise HTTPException(status_code=500, detail="Zip archive payload was invalid") from exc

            manifest = {
                "metadata": result.get("metadata", {}),
                "slices": [
                    {k: v for k, v in slice_payload.items() if k != "base64"}
                    for slice_payload in result.get("slices", [])
                ],
                "full_view": {
                    k: v
                    for k, v in result.get("full_view", {}).items()
                    if k != "base64"
                },
            }
            manifest_json = json.dumps(manifest, ensure_ascii=False)
            headers = {
                "Content-Disposition": _content_disposition(zip_payload.get("filename", "panosplitter_slices.zip")),
                "X-Panosplitter-Manifest": base64.b64encode(manifest_json.encode("utf-8")).decode("utf-8"),
            }

            return Response(content=zip_bytes, media_type=zip_payload.get("content_type", "application/zip"), headers=headers)

        return result
    except JavaScriptToolError as exc:
        logger.error("JavaScript tool failed: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover - FastAPI will re-raise as HTTP 500
        logger.exception("Unexpected error running panosplitter")
        raise HTTPException(status_code=500, detail="Failed to process image") from exc


@router.post(
    "/cobalt",
    response_model=Dict[str, Any],
    responses={
        200: {
            "content": {
                "application/zip": {"schema": {"type": "string", "format": "binary"}},
                "application/octet-stream": {"schema": {"type": "string", "format": "binary"}},
            }
        }
    },
)
async def cobalt_endpoint(request: CobaltRequest):
    """Proxy media download requests to a configured Cobalt instance."""

    if not settings.COBALT_API_BASE_URL:
        raise HTTPException(status_code=503, detail="Cobalt integration is not configured")

    service = CobaltService(
        base_url=settings.COBALT_API_BASE_URL,
        auth_scheme=settings.COBALT_API_AUTH_SCHEME,
        auth_token=settings.COBALT_API_AUTH_TOKEN,
        timeout=settings.COBALT_API_TIMEOUT,
    )

    try:
        cobalt_result = await service.process(request.to_payload())
        if request.response_format == "binary":
            binary = await service.download_binary(cobalt_result, filename_override=request.download_filename)
            headers = {
                "Content-Disposition": _content_disposition(binary.filename),
                "X-Cobalt-Metadata": binary.encoded_metadata,
            }
            return Response(content=binary.content, media_type=binary.content_type, headers=headers)

        return cobalt_result
    except CobaltError as exc:
        logger.error("Cobalt integration failed: %s", exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc
