import base64
import json
from typing import Any, Dict, Literal
from urllib.parse import quote

from fastapi import APIRouter, File, Form, HTTPException, UploadFile, Query, Response
from fastapi.responses import JSONResponse
from pydantic import AnyHttpUrl, BaseModel, ConfigDict, Field

from app.config import settings
from app.services.cobalt_gateway import CobaltGateway, create_gateway
from app.services.cobalt_service import CobaltError
from app.services.cobalt_shortcuts import SHORTCUT_REGISTRY
from app.services.js_tool_service import JavaScriptToolError, run_panosplitter
from app.utils.logger import logger

router = APIRouter(prefix="/js-tools", tags=["javascript-tools"])


class ImagePayload(BaseModel):
    filename: str
    content_type: str
    base64: str = Field(..., description="Base64 encoded image data")
    width: int | None = None
    height: int | None = None


class ZipPayload(BaseModel):
    filename: str
    base64: str = Field(..., description="Base64 encoded zip archive")
    content_type: str


class PanosplitterMetadata(BaseModel):
    mode: str
    slice_count: int
    slice_width: int
    slice_height: int
    scaled_width: int
    scaled_height: int
    original_filename: str


class PanosplitterResponse(BaseModel):
    metadata: PanosplitterMetadata
    zip_file: ZipPayload
    slices: list[ImagePayload]
    full_view: ImagePayload
    manifest: Dict[str, Any] | None = Field(
        default=None,
        description="Lightweight manifest describing generated assets (included in the binary zip as manifest.json)",
    )


class CobaltRequest(BaseModel):
    url: AnyHttpUrl
    response_format: Literal["json", "binary"] = Field(
        "json",
        description="Set to 'binary' to receive the downloaded media directly as an octet-stream response.",
    )
    download_filename: str | None = Field(
        default=None,
        description="Override the filename suggested by the Cobalt service when requesting binary output.",
    )

    model_config = ConfigDict(extra="allow")

    def to_payload(self) -> Dict[str, Any]:
        payload = self.model_dump(exclude={"response_format", "download_filename"})
        payload["url"] = str(self.url)
        return payload


def _content_disposition(filename: str) -> str:
    encoded = quote(filename)
    return f"attachment; filename*=UTF-8''{encoded}"


_cobalt_gateway: CobaltGateway | None = None


def _get_cobalt_service() -> CobaltGateway:
    global _cobalt_gateway
    if _cobalt_gateway is None:
        try:
            _cobalt_gateway = create_gateway(
                remote_base_url=settings.COBALT_API_BASE_URL,
                auth_scheme=settings.COBALT_API_AUTH_SCHEME,
                auth_token=settings.COBALT_API_AUTH_TOKEN,
                timeout=settings.COBALT_API_TIMEOUT,
            )
        except CobaltError as exc:
            raise HTTPException(status_code=503, detail=str(exc)) from exc

    return _cobalt_gateway


class CobaltShortcutRequest(BaseModel):
    url: AnyHttpUrl
    response_format: Literal["json", "binary"] | None = Field(
        default=None,
        description="Override the shortcut response format ('json' or 'binary').",
    )
    download_filename: str | None = Field(
        default=None,
        description="Optional filename override when requesting binary output.",
    )
    options: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional Cobalt payload fields to merge with the shortcut preset.",
    )

    model_config = ConfigDict(extra="forbid")

    def to_payload(self, preset: Dict[str, Any]) -> Dict[str, Any]:
        payload = {**preset, **self.options}
        payload["url"] = str(self.url)
        return payload


@router.post("/panosplitter", response_model=PanosplitterResponse)
async def panosplitter_endpoint(
    image: UploadFile = File(..., description="Panorama image to split"),
    high_res: bool = Form(False, description="Use the high resolution splitting mode"),
    response_format: Literal["json", "binary"] = Query(
        "json",
        description="Set to 'binary' to receive a zip file instead of a JSON payload.",
    ),
):
    """Split a panorama image into Instagram-friendly slices using the JavaScript toolchain."""

    try:
        image_bytes = await image.read()
        if not image_bytes:
            raise HTTPException(status_code=400, detail="Uploaded file is empty")

        result = run_panosplitter(image_bytes, high_res=high_res, filename=image.filename)

        if response_format == "binary":
            zip_payload = result.get("zip_file", {})
            zip_base64 = zip_payload.get("base64")
            if not zip_base64:
                raise HTTPException(status_code=500, detail="Zip archive was not generated by the JavaScript tool")

            try:
                zip_bytes = base64.b64decode(zip_base64)
            except (TypeError, ValueError) as exc:
                raise HTTPException(status_code=500, detail="Zip archive payload was invalid") from exc

            manifest = {
                "metadata": result.get("metadata", {}),
                "slices": [
                    {k: v for k, v in slice_payload.items() if k != "base64"}
                    for slice_payload in result.get("slices", [])
                ],
                "full_view": {
                    k: v
                    for k, v in result.get("full_view", {}).items()
                    if k != "base64"
                },
            }
            manifest_json = json.dumps(manifest, ensure_ascii=False)
            headers = {
                "Content-Disposition": _content_disposition(zip_payload.get("filename", "panosplitter_slices.zip")),
                "X-Panosplitter-Manifest": base64.b64encode(manifest_json.encode("utf-8")).decode("utf-8"),
            }

            return Response(content=zip_bytes, media_type=zip_payload.get("content_type", "application/zip"), headers=headers)

        return result
    except JavaScriptToolError as exc:
        logger.error("JavaScript tool failed: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover - FastAPI will re-raise as HTTP 500
        logger.exception("Unexpected error running panosplitter")
        raise HTTPException(status_code=500, detail="Failed to process image") from exc


@router.post(
    "/cobalt",
    response_model=Dict[str, Any],
    responses={
        200: {
            "content": {
                "application/zip": {"schema": {"type": "string", "format": "binary"}},
                "application/octet-stream": {"schema": {"type": "string", "format": "binary"}},
            }
        }
    },
)
async def cobalt_endpoint(request: CobaltRequest):
    """Proxy media download requests to a configured Cobalt instance."""

    try:
        result = await _get_cobalt_service().process(
            request.to_payload(),
            expect_binary=request.response_format == "binary",
            filename_override=request.download_filename,
        )
        backend = "local" if result.used_local_fallback else "remote"
        headers = {
            "X-Cobalt-Backend": backend,
            "X-Cobalt-Source": result.source_label,
        }

        if request.response_format == "binary":
            if result.binary is None:
                raise CobaltError("Cobalt backend did not return a binary payload")

            binary = result.binary
            headers.update(
                {
                    "Content-Disposition": _content_disposition(binary.filename),
                    "X-Cobalt-Metadata": binary.encoded_metadata,
                }
            )
            return Response(content=binary.content, media_type=binary.content_type, headers=headers)

        return JSONResponse(content=result.payload, headers=headers)
    except CobaltError as exc:
        logger.error("Cobalt integration failed: %s", exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc


@router.post(
    "/cobalt/shortcuts/{shortcut}",
    response_model=Dict[str, Any],
    responses={
        200: {
            "content": {
                "application/zip": {"schema": {"type": "string", "format": "binary"}},
                "application/octet-stream": {"schema": {"type": "string", "format": "binary"}},
            }
        }
    },
)
async def cobalt_shortcut(shortcut: str, request: CobaltShortcutRequest):
    """Execute a preconfigured Cobalt request with minimal input."""

    shortcut_key = shortcut.lower()
    shortcut_config = SHORTCUT_REGISTRY.get(shortcut_key)
    if not shortcut_config:
        raise HTTPException(status_code=404, detail=f"Unknown Cobalt shortcut: {shortcut}")

    try:
        payload = request.to_payload(shortcut_config.payload)
        response_format = request.response_format or shortcut_config.response_format
        result = await _get_cobalt_service().process(
            payload,
            expect_binary=response_format == "binary",
            filename_override=request.download_filename,
        )
        backend = "local" if result.used_local_fallback else "remote"
        headers = {
            "X-Cobalt-Backend": backend,
            "X-Cobalt-Source": result.source_label,
        }

        if response_format == "binary":
            if result.binary is None:
                raise CobaltError("Cobalt backend did not return a binary payload")

            binary = result.binary
            headers.update(
                {
                    "Content-Disposition": _content_disposition(binary.filename),
                    "X-Cobalt-Metadata": binary.encoded_metadata,
                }
            )
            return Response(content=binary.content, media_type=binary.content_type, headers=headers)

        body: Dict[str, Any] = {
            "shortcut": shortcut_config.slug,
            "status": result.payload.get("status"),
            "download_url": result.payload.get("url"),
            "filename": result.payload.get("filename"),
            "metadata": result.payload,
        }
        if request.download_filename:
            body["download_filename"] = request.download_filename

        return JSONResponse(content=body, headers=headers)
    except CobaltError as exc:
        logger.error("Cobalt shortcut '%s' failed: %s", shortcut_key, exc)
        raise HTTPException(status_code=502, detail=str(exc)) from exc
